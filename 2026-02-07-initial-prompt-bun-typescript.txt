
 ▐▛███▜▌   Claude Code v2.1.34
▝▜█████▛▘  Opus 4.6 · Claude Team
  ▘▘ ▝▝    ~/src/nvim-lsp-bridge

❯ I am trying to read diagnostics from a running instance of neovim         
  using a bun bridge script: @index.ts                                      
                                                                            
  For more context, see this prompt:                                        
  @/Users/robcmills/.local/share/nvim/prompt/history/2026-02-06T13:47:36-cl 
  aude-access-neovim-lsps.md                                                
                                                                            
  I've already run                                                          
  ```                                                                       
  nvim --listen /tmp/nvim.sock                                              
  ```                                                                       
                                                                            
  Now we just need to get the bun script to work.                           
                                                                            
  Run:                                                                      
  ```                                                                       
  bun run index.ts diagnostics                                              
  ```                                                                       
                                                                            
  and fix any issues, until it works.                                       
  ⎿  Read index.ts (264 lines)
  ⎿ Read ../../.local/share/nvim/prompt/history/2026-02-06T13:47:36-claude-acces
    -neovim-lsps.md (528 lines)

⏺ Bash(bun run index.ts diagnostics 2>&1)
  ⎿  Error: Exit code 1
     Error:  6 | const logger_1 = require("../utils/logger");
      7 | function attach({ reader: _reader, writer: _writer, proc, socket, 
     options = {} }) {
      8 |     let writer;
      9 |     let reader;
     10 |     if (socket) {
     11 |         const client = (0, node_net_1.createConnection)(socket);
                                                ^
     TypeError: The "options" or "port" or "path" argument must be specified
      code: "ERR_MISSING_ARGS"
     … +9 lines (ctrl+o to see all)

⏺ The attach function expects the socket to be passed differently. The neovim
  package's attach expects a socket option as a path string, but the code is
  passing a net.Socket object. Let me check the neovim package's attach function
   signature.

⏺ Read 1 file (ctrl+o to expand)

⏺ The attach function passes the socket parameter directly to createConnection
  itself. The code is double-wrapping — it creates a socket, then attach tries
  to use that socket as an argument to createConnection again. The fix is to
  pass the path string directly.

⏺ Update(index.ts)
  ⎿  Added 1 line, removed 3 lines
       1  import { attach } from "neovim";
       2 -import { createConnection } from "net";                        
       2  
       3  const SOCKET_PATH = process.env.NVIM_LISTEN_ADDRESS || "/tmp/nv
          im.sock";
       4  
       5  async function connectToNvim() {
       7 -  const socket = createConnection(SOCKET_PATH);                
       8 -  const nvim = attach({ socket });                             
       6 +  const nvim = attach({ socket: SOCKET_PATH });                
       7    return nvim;
       8  }
       9  

⏺ There's also a bug on line 33 — vim.NIL doesn't exist in the TypeScript
  context. Let me fix that too.

⏺ Update(index.ts)
  ⎿  Added 1 line, removed 1 line
      28        end
      29      end
      30      return results
      31 -  `, [file || vim.NIL]);                                       
      31 +  `, [file || null]);                                          
      32  
      33    nvim.quit();
      34    return diagnostics;

⏺ Now let's run it again.

⏺ Bash(bun run index.ts diagnostics 2>&1)
  ⎿  (No content)

⏺ The command returned with no output, which likely means it got empty results.
  Let me check if there's a connection issue or if the diagnostics are simply
  empty. Let me also check if nvim.quit() is working properly — it might be
  hanging.

⏺ Bash(timeout 10 bun run index.ts diagnostics 2>&1; echo "EXIT CODE: $?")
  ⎿  Interrupted · What should Claude do instead?

❯ I just introduced some type errors, so try again 

⏺ Bash(bun run index.ts diagnostics 2>&1)
  ⎿  Error: Exit code 1

⏺ No output at all — let me try capturing both streams more explicitly.

⏺ Bash(bun run index.ts diagnostics 1>/tmp/nvim-bridge-stdout.txt
      2>/tmp/nvim-bridge-stderr.txt; echo "exit: $?")
  ⎿  exit: 1

⏺ Read 2 files (ctrl+o to expand)

⏺ Both empty. The process might be hanging and getting killed. Let me try a
  minimal connection test first.

⏺ Bash(bun -e 'import { attach } from "neovim"; const nvim = attach({ socket:
      "/tmp/nvim.sock" }); const v = await nvim.commandOutput("echo 42");
      console.log("got:", v…)
  ⎿  (No content)

⏺ Bash(bun -e '
      import { attach } from "neovim";…)
  ⎿  Running in the background (↓ to manage)
  ⎿  (timeout 10s)

⏺ Read 1 file (ctrl+o to expand)

⏺ The socket file /tmp/nvim.sock doesn't exist — Neovim isn't listening there.
  Let me find where your Neovim instance is actually listening.

⏺ Bash(ls /tmp/nvim* 2>/dev/null; echo "---"; ls /run/user/*/nvim* 2>/dev/null;
      echo "---"; echo $NVIM_LISTEN_ADDRESS; echo "---"; ls /tmp/nvim.*/0
      2>/dev/null)
  ⎿  Error: Exit code 1
     /tmp/nvim-bridge-stderr.txt
     /tmp/nvim-bridge-stdout.txt
     ---
     ---

     ---

⏺ Bash(ls -la /var/folders/*/*/T/nvim*/0 2>/dev/null; echo "==="; lsof -c nvim
      2>/dev/null | grep -i "unix\|sock\|listen")
  ⎿  ===
     nvim    33287 robcmills   10u    unix 0x64d704e854756875        0t0
                      ->0xaf974d896c9ed41a
     … +233 lines (ctrl+o to expand)

⏺ The socket /tmp/nvim.sock doesn't exist. Your Neovim instances are using
  auto-generated socket paths. You have several running — let me pick the most
  recent one and test with that.

⏺ Read 1 file (ctrl+o to expand)

⏺ The most recent socket is from today. Let me test with it.

⏺ Bash(NVIM_LISTEN_ADDRESS="/var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvi
      m.robcmills/yVWXFr/nvim.58870.0" bun -e '
      import { attach } from "neovim";…)
  ⎿  (No content)

⏺ Bash(NVIM_LISTEN_ADDRESS="/var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvi
      m.robcmills/yVWXFr/nvim.58870.0" bun -e '
      import { attach } from "neovim";…)
  ⎿  Error: Exit code 1
     1 | 
     2 | import { attach } from "neovim";
     3 | const nvim = attach({ socket: process.env.NVIM_LISTEN_ADDRESS });
     4 | const v = await nvim.commandOutput("echo 42");
     5 | console.log("got:", v);
     6 | nvim.detach();
              ^
     TypeError: nvim.detach is not a function. (In 'nvim.detach()', 'nvim.detach
      is undefined)
           at /Users/robcmills/src/nvim-lsp-bridge/[eval]:6:6
     … +2 lines (ctrl+o to see all)

⏺ Bash(NVIM_LISTEN_ADDRESS="/var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvi
      m.robcmills/yVWXFr/nvim.58870.0" bun -e '
      import { attach } from "neovim";…)
  ⎿  Running in the background (↓ to manage)
  ⎿  (timeout 10s)

⏺ Task Output bcfbf0c
  ⎿  (No content)

⏺ The process hangs — the socket connection keeps it alive. Let me check how to
  properly disconnect.

⏺ Stop Task
  ⎿ NVIM_LISTEN_ADDRESS="/var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/n
    vim.robcmills/yVWXFr/nvim.58870.0" bun -e '
    import { attach } from "neovim";… · stopped

⏺ Read 1 file (ctrl+o to expand)

⏺ Bash(NVIM_LISTEN_ADDRESS="/var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvi
      m.robcmills/yVWXFr/nvim.58870.0" bun -e '
      import { attach } from "neovim";…)
  ⎿  (No content)

⏺ Bash(NVIM_LISTEN_ADDRESS="/var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvi
      m.robcmills/yVWXFr/nvim.58870.0" bun -e '
      import { attach } from "neovim";…)
  ⎿  (No content)
  ⎿  (timeout 10s)

⏺ Bash(NVIM_LISTEN_ADDRESS="/var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvi
      m.robcmills/yVWXFr/nvim.58870.0" bun -e '
      import { writeFileSync } from "fs";…)
  ⎿  === log ===
     start
     attached
     … +3 lines (ctrl+o to expand)
  ⎿  (timeout 15s)

⏺ It works! The connection succeeds and returns 42. The issue was just output
  buffering/timing. Now let me test the actual diagnostics query. But first, the
   key problem: nvim.quit() sends :qa! which would quit your Neovim. We need to
  just destroy the socket instead. Let me update the script.

⏺ Read 1 file (ctrl+o to expand)

⏺ I need to fix three things:

  1. nvim.quit() sends :qa! which would quit your Neovim — need to disconnect
  the socket instead
  2. connectToNvim needs to use reader/writer pattern so we have a handle to
  destroy the socket
  3. Auto-detect the socket path since /tmp/nvim.sock doesn't exist (Neovim uses
   $TMPDIR paths on macOS)

⏺ Write(index.ts)
  ⎿  Added 79 lines, removed 37 lines
       1 -import { attach } from "neovim";                               
       1 +import { attach, type NeovimClient } from "neovim";            
       2 +import { createConnection, type Socket } from "net";           
       3 +import { readdirSync, statSync } from "fs";                    
       4 +import { join } from "path";                                   
       5 +import { tmpdir } from "os";                                   
       6  
       3 -const SOCKET_PATH = process.env.NVIM_LISTEN_ADDRESS || "/tmp/nv
         -im.sock";                                                      
       7 +function findNeovimSocket(): string {                          
       8 +  if (process.env.NVIM_LISTEN_ADDRESS) {                       
       9 +    return process.env.NVIM_LISTEN_ADDRESS;                    
      10 +  }                                                            
      11  
       5 -async function connectToNvim() {                               
       6 -  const nvim = attach({ socket: SOCKET_PATH });                
       7 -  return nvim;                                                 
      12 +  // On macOS, Neovim sockets are in $TMPDIR/nvim.$USER/*/nvim.
         +*.0                                                            
      13 +  const user = process.env.USER || "unknown";                  
      14 +  const nvimDir = join(tmpdir(), `nvim.${user}`);              
      15 +                                                               
      16 +  try {                                                        
      17 +    const subdirs = readdirSync(nvimDir);                      
      18 +    let newest = { path: "", mtime: 0 };                       
      19 +    for (const sub of subdirs) {                               
      20 +      const subPath = join(nvimDir, sub);                      
      21 +      const files = readdirSync(subPath);                      
      22 +      for (const f of files) {                                 
      23 +        if (f.startsWith("nvim.") && f.endsWith(".0")) {       
      24 +          const fullPath = join(subPath, f);                   
      25 +          const st = statSync(fullPath);                       
      26 +          if (st.mtimeMs > newest.mtime) {                     
      27 +            newest = { path: fullPath, mtime: st.mtimeMs };    
      28 +          }                                                    
      29 +        }                                                      
      30 +      }                                                        
      31 +    }                                                          
      32 +    if (newest.path) return newest.path;                       
      33 +  } catch {}                                                   
      34 +                                                               
      35 +  throw new Error(                                             
      36 +    "No Neovim socket found. Start Neovim with: nvim --listen /
         +tmp/nvim.sock\n" +                                             
      37 +    "Or set NVIM_LISTEN_ADDRESS environment variable."         
      38 +  );                                                           
      39  }
      40  
      41 +function connectToNvim(): { nvim: NeovimClient; socket: Socket 
         +} {                                                            
      42 +  const socketPath = findNeovimSocket();                       
      43 +  const socket = createConnection(socketPath);                 
      44 +  const nvim = attach({ reader: socket, writer: socket });     
      45 +  return { nvim, socket };                                     
      46 +}                                                              
      47 +                                                               
      48 +function disconnect(socket: Socket): void {                    
      49 +  socket.destroy();                                            
      50 +}                                                              
      51 +                                                               
      52  async function getDiagnostics(file?: string) {
      11 -  const nvim = await connectToNvim();                          
      53 +  const { nvim, socket } = connectToNvim();                    
      54  
      55    const diagnostics = await nvim.lua(`
      56      local diags = vim.diagnostic.get()
     ...
       72      return results
       73    `, [file || null]);
       74  
       33 -  nvim.quit();                                                
       75 +  disconnect(socket);                                         
       76    return diagnostics;
       77  }
       78  
       79  async function getHover(file: string, line: number, col: numbe
           r) {
       38 -  const nvim = await connectToNvim();                         
       80 +  const { nvim, socket } = connectToNvim();                   
       81  
       82    const result = await nvim.lua(`
       83      local file, line, col = ...
       42 -                                                              
       84 +                                                              
       85      -- Find or open the buffer
       86      local bufnr = vim.fn.bufnr(file)
       87      if bufnr == -1 then
       88        vim.cmd('badd ' .. file)
       89        bufnr = vim.fn.bufnr(file)
       90      end
       49 -                                                              
       91 +                                                              
       92      -- Get LSP clients for this buffer
       93      local clients = vim.lsp.get_clients({ bufnr = bufnr })
       94      if #clients == 0 then
       95        return { error = "No LSP client attached to " .. file }
       96      end
       55 -                                                              
       97 +                                                              
       98      -- Synchronous hover request
       99      local params = {
      100        textDocument = vim.lsp.util.make_text_document_params(bu
           fnr),
      101        position = { line = line - 1, character = col - 1 }
      102      }
       61 -                                                              
      103 +                                                              
      104      local responses = vim.lsp.buf_request_sync(bufnr, 'textDoc
           ument/hover', params, 3000)
      105      if not responses then
      106        return { error = "No hover response" }
      107      end
       66 -                                                              
      108 +                                                              
      109      for _, resp in pairs(responses) do
      110        if resp.result and resp.result.contents then
      111          local contents = resp.result.contents
     ...
      115          return { result = tostring(contents) }
      116        end
      117      end
       76 -                                                              
      118 +                                                              
      119      return { error = "No hover info found" }
      120    `, [file, line, col]);
      121  
       80 -  nvim.quit();                                                
      122 +  disconnect(socket);                                         
      123    return result;
      124  }
      125  
      126  async function getDefinition(file: string, line: number, col: 
           number) {
       85 -  const nvim = await connectToNvim();                         
      127 +  const { nvim, socket } = connectToNvim();                   
      128  
      129    const result = await nvim.lua(`
      130      local file, line, col = ...
       89 -                                                              
      131 +                                                              
      132      local bufnr = vim.fn.bufnr(file)
      133      if bufnr == -1 then
      134        vim.cmd('badd ' .. file)
      135        bufnr = vim.fn.bufnr(file)
      136      end
       95 -                                                              
      137 +                                                              
      138      local params = {
      139        textDocument = vim.lsp.util.make_text_document_params(bu
           fnr),
      140        position = { line = line - 1, character = col - 1 }
      141      }
      100 -                                                              
      142 +                                                              
      143      local responses = vim.lsp.buf_request_sync(bufnr, 'textDoc
           ument/definition', params, 3000)
      144      if not responses then
      145        return { error = "No definition response" }
      146      end
      105 -                                                              
      147 +                                                              
      148      local results = {}
      149      for _, resp in pairs(responses) do
      150        if resp.result then
     ...
      162          end
      163        end
      164      end
      123 -                                                              
      165 +                                                              
      166      return results
      167    `, [file, line, col]);
      168  
      127 -  nvim.quit();                                                
      169 +  disconnect(socket);                                         
      170    return result;
      171  }
      172  
      173  async function getReferences(file: string, line: number, col: 
           number) {
      132 -  const nvim = await connectToNvim();                         
      174 +  const { nvim, socket } = connectToNvim();                   
      175  
      176    const result = await nvim.lua(`
      177      local file, line, col = ...
      136 -                                                              
      178 +                                                              
      179      local bufnr = vim.fn.bufnr(file)
      180      if bufnr == -1 then
      181        vim.cmd('badd ' .. file)
      182        bufnr = vim.fn.bufnr(file)
      183      end
      142 -                                                              
      184 +                                                              
      185      local params = {
      186        textDocument = vim.lsp.util.make_text_document_params(bu
           fnr),
      187        position = { line = line - 1, character = col - 1 },
      188        context = { includeDeclaration = true }
      189      }
      148 -                                                              
      190 +                                                              
      191      local responses = vim.lsp.buf_request_sync(bufnr, 'textDoc
           ument/references', params, 5000)
      192      if not responses then
      193        return { error = "No references response" }
      194      end
      153 -                                                              
      195 +                                                              
      196      local results = {}
      197      for _, resp in pairs(responses) do
      198        if resp.result then
     ...
      205          end
      206        end
      207      end
      166 -                                                              
      208 +                                                              
      209      return results
      210    `, [file, line, col]);
      211  
      170 -  nvim.quit();                                                
      212 +  disconnect(socket);                                         
      213    return result;
      214  }
      215  
      216  async function getCompletions(file: string, line: number, col:
            number) {
      175 -  const nvim = await connectToNvim();                         
      217 +  const { nvim, socket } = connectToNvim();                   
      218  
      219    const result = await nvim.lua(`
      220      local file, line, col = ...
      179 -                                                              
      221 +                                                              
      222      local bufnr = vim.fn.bufnr(file)
      223      if bufnr == -1 then
      224        vim.cmd('badd ' .. file)
      225        bufnr = vim.fn.bufnr(file)
      226      end
      185 -                                                              
      227 +                                                              
      228      local params = {
      229        textDocument = vim.lsp.util.make_text_document_params(bu
           fnr),
      230        position = { line = line - 1, character = col - 1 }
      231      }
      190 -                                                              
      232 +                                                              
      233      local responses = vim.lsp.buf_request_sync(bufnr, 'textDoc
           ument/completion', params, 3000)
      234      if not responses then
      235        return { error = "No completion response" }
      236      end
      195 -                                                              
      237 +                                                              
      238      local results = {}
      239      for _, resp in pairs(responses) do
      240        if resp.result then
     ...
      249          end
      250        end
      251      end
      210 -                                                              
      252 +                                                              
      253      return results
      254    `, [file, line, col]);
      255  
      214 -  nvim.quit();                                                
      256 +  disconnect(socket);                                         
      257    return result;
      258  }
      259  
     ...
      283          break;
      284        default:
      285          console.error(`Usage: nvim-lsp <command> [args...]
      244 -                                                              
      286 +                                                              
      287  Commands:
      288    diagnostics [file]              Get LSP diagnostics
      289    hover <file> <line> <col>       Get hover/type info

⏺ Now let's test it. I'll write output to a file since Bun's stdout buffering
  causes issues with the tool.

⏺ Bash(bun run index.ts diagnostics > /tmp/nvim-diag-out.txt 2>&1 &
      PID=$!…)
  ⎿  exit: 1
  ⎿  (timeout 15s)

⏺ Bash(bun -e '
      import { writeFileSync } from "fs";…)
  ⎿ tmpdir: /var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T
    nvimDir: /var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvim.robcmill
    s
    … +2 lines (ctrl+o to expand)


⏺ Socket detection works. Let me test the full diagnostics flow with debug
  logging.

⏺ Bash(bun -e '
      import { writeFileSync } from "fs";…)
  ⎿ === start ===
    socket: /var/folders/67/18nnk5bx46560jrc36v2nht40000gn/T/nvim.robcmills
    /yVWXFr/nvim.58870.0
    … +3 lines (ctrl+o to expand)

  ⎿  (timeout 15s)

⏺ 14 diagnostics found. The connection and Lua call work. Now let me test the
  full diagnostics command from the actual script, but the issue is that
  console.log output gets lost. Let me add a flush/exit to main().

⏺ Update(index.ts)
  ⎿  Added 4 lines, removed 1 line
      293          process.exit(1);
      294      }
      295  
      296 -    console.log(JSON.stringify(result, null, 2));             
      296 +    const output = JSON.stringify(result, null, 2);           
      297 +    await new Promise<void>((resolve) => {                    
      298 +      process.stdout.write(output + "\n", () => resolve());   
      299 +    });                                                       
      300    } catch (err) {
      301      console.error("Error:", err);
      302      process.exit(1);

⏺ Bash(bun run index.ts diagnostics > /tmp/nvim-diag-out.txt
      2>/tmp/nvim-diag-err.txt &
      PID=$!…)
  ⎿  === stdout ===
     === stderr ===
  ⎿  (timeout 15s)

⏺ The process is hanging — socket.destroy() isn't enough to let Bun's event loop
   exit. Let me add an explicit process.exit(0) after outputting the result.

⏺ Update(index.ts)
  ⎿  Added 1 line
      297      await new Promise<void>((resolve) => {
      298        process.stdout.write(output + "\n", () => resolve());
      299      });
      300 +    process.exit(0);                                          
      301    } catch (err) {
      302      console.error("Error:", err);
      303      process.exit(1);

⏺ Bash(bun run index.ts diagnostics 2>&1)
  ⎿  Error: Exit code 1

⏺ Bash(bun run index.ts diagnostics 1>/tmp/out.txt 2>/tmp/err.txt; echo "exit:
      $?"; echo "=== stdout ==="; cat /tmp/out.txt; echo "=== stderr ==="; cat
      /tmp/err.txt)
  ⎿  exit: 1
     === stdout ===
     === stderr ===

⏺ Update(index.ts)
  ⎿  Added 5 lines, removed 1 line
      299      });
      300      process.exit(0);
      301    } catch (err) {
      302 -    console.error("Error:", err);                             
      302 +    const { writeFileSync } = await import("fs");             
      303 +    writeFileSync("/tmp/nvim-bridge-error.log", String(err) + 
          +"\n" + (err instanceof Error ? err.stack : ""));              
      304 +    await new Promise<void>((resolve) => {                    
      305 +      process.stderr.write("Error: " + String(err) + "\n", () 
          +=> resolve());                                                
      306 +    });                                                       
      307      process.exit(1);
      308    }
      309  }

⏺ Bash(bun run index.ts diagnostics 2>&1; echo "---"; cat
      /tmp/nvim-bridge-error.log 2>/dev/null)
  ⎿ Error: Error: nvim_execute_lua: Error executing lua: [string "<nvim>"]:
    7: bad argument #1 to 'find' (string expected, got userdata)
    stack traceback:
    … +16 lines (ctrl+o to expand)


⏺ Now we can see the error. When no file filter is passed, null is being sent as
   msgpack nil but Lua receives it as userdata instead of nil. The
  fname:find(filter_file, ...) call chokes on it. The fix: don't pass the filter
   arg at all when there's no file.

⏺ Update(index.ts)
  ⎿  Added 4 lines, removed 3 lines
      52  async function getDiagnostics(file?: string) {
      53    const { nvim, socket } = connectToNvim();
      54  
      55 +  const luaArgs = file ? [file] : [];                          
      56    const diagnostics = await nvim.lua(`
      57 +    local filter_file = select(1, ...)                         
      58      local diags = vim.diagnostic.get()
      59      local results = {}
      58 -    local filter_file = ...                                    
      60      for _, d in ipairs(diags) do
      61        local fname = vim.api.nvim_buf_get_name(d.bufnr or 0)
      61 -      if not filter_file or fname:find(filter_file, 1, true) th
         -en                                                             
      62 +      if filter_file == nil or fname:find(filter_file, 1, true)
         + then                                                          
      63          table.insert(results, {
      64            file = fname,
      65            line = d.lnum + 1,
     ...
      71        end
      72      end
      73      return results
      73 -  `, [file || null]);                                          
      74 +  `, luaArgs);                                                 
      75  
      76    disconnect(socket);
      77    return diagnostics;

⏺ Bash(bun run index.ts diagnostics 2>&1)
  ⎿  [
       {
         "severity": 1,
     … +135 lines (ctrl+o to expand)

⏺ It works! 14 diagnostics returned from your Neovim's LSP. The diagnostics are
  actually about index.ts itself — I can see the type errors you introduced. The
   bridge is functional.

  The key fixes were:
  1. attach({ socket: SOCKET_PATH }) — pass path as reader/writer via
  createConnection so we have a socket handle to destroy (instead of nvim.quit()
   which sends :qa! and would close Neovim)
  2. Auto-detect socket path — scans $TMPDIR/nvim.$USER/ for the most recently
  modified socket
  3. Pass empty array [] when no file filter — passing null results in Lua
  userdata, not nil
  4. process.exit(0) after output — Bun's event loop stays alive due to the
  socket; explicit exit needed
  5. process.stdout.write with callback — ensures output flushes before
  process.exit

✻ Cooked for 4m 24s